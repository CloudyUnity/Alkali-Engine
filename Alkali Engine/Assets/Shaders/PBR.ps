#define BUMP_2_CHANNEL 1

#define PI 3.141592654f

#define CASCADES 3

struct V_OUT
{
    float4 Position : SV_Position;
    float2 UV : TEXCOORD0;
    float3 Normal : NORMAL;    
    float3 Tangent : TANGENT;
    float3 Binormal : BINORMAL;

    float3 ViewDirection : TEXCOORD1;
    float3 ShadowMapCoords[CASCADES] : TEXCOORD2;
};

struct DirectionalLight
{
    float3 AmbientColor;
    float p1;

    float3 LightDirection;
    float p2;

    float3 LightColor;
    float SpecularPower;
};
ConstantBuffer<DirectionalLight> DirLightCB : register(b3);

struct ShadowMapPixel
{
    float4 CascadeDistances; // Max 4 cascades
};
ConstantBuffer<ShadowMapPixel> ShadowPixelCB : register(b5);

struct MaterialProperties
{
    float3 BaseColorFactor;
    float Roughness;    

    float AlphaCutoff;
    float IOR;
    float Dispersion;
    float Metallic; // Unused until fixed
};
ConstantBuffer<MaterialProperties> MatPropCB : register(b1);

Texture2D g_texture : register(t0);
Texture2D g_normalMap : register(t1);
Texture2D g_specularMap : register(t2);
TextureCube g_irradiance : register(t3);
TextureCube g_envMap : register(t4);
Texture2D g_shadowMap : register(t5);

SamplerState g_sampler : register(s0);

float D_GGX(float NdH, float roughness);
float3 F_Schlick(float cosTheta, float3 F0);
float G_Smith(float NdL, float NdV, float roughness);
float G_Smith_IBL(float NdL, float NdV, float roughness);

float4 main(V_OUT input) : SV_Target
{
    float4 zDist = input.Position.zzzz / input.Position.w;
    float4 cascadeComparison = (zDist > ShadowPixelCB.CascadeDistances);
    return float4(zDist.xyz, 1);
    return float4(cascadeComparison.xyz, 1);

    float fCascadeIndex = dot(float4(CASCADES > 0, CASCADES > 1, CASCADES > 2, CASCADES > 3), cascadeComparison);
    fCascadeIndex = min(fCascadeIndex, CASCADES); // Why?
    int iCascadeIndex = (int)fCascadeIndex;

    float3 shadowCoords = input.ShadowMapCoords[iCascadeIndex];
    shadowCoords.y = 1 - shadowCoords.y;
    float shadowMapDepth = g_shadowMap.Sample(g_sampler, shadowCoords.xy).r;
    bool inLight = shadowCoords.z + 0.0001f < shadowMapDepth;

    return float4(shadowCoords.xy, 0, 1);

    if (!inLight)
        return float4(0, 0, 0, 1);

    float4 tex = g_texture.Sample(g_sampler, input.UV);    

    if (tex.a < MatPropCB.AlphaCutoff)
        discard;

    tex.rgb = pow(tex.rgb, 2.2f);

#if BUMP_2_CHANNEL
    float2 bump = g_normalMap.Sample(g_sampler, input.UV).rg;

    float3 normalTangentSpace;
    normalTangentSpace.xy = bump * 2.0f - 1.0f;
    normalTangentSpace.z = sqrt(1.0f - dot(normalTangentSpace.xy, normalTangentSpace.xy));
#else
    float3 normalTangentSpace = g_normalMap.Sample(g_sampler, input.UV).rgb;
    normalTangentSpace.xyz = normalTangentSpace.xyz * 2.0f - 1.0f;
#endif    

    float3 occlusionRoughnessMetallic = g_specularMap.Sample(g_sampler, input.UV).rgb;    
    float roughness = occlusionRoughnessMetallic.g * MatPropCB.Roughness;
    float metalness = occlusionRoughnessMetallic.b * MatPropCB.Metallic;

    float3 N = normalize(normalTangentSpace.x * input.Tangent + normalTangentSpace.y * input.Binormal + normalTangentSpace.z * input.Normal);    
    float3 L = normalize(DirLightCB.LightDirection);
    float3 V = normalize(input.ViewDirection);
    float3 H = normalize(-L + V);
    float3 R = reflect(-V, N);

    float NdL = saturate(dot(N, -L));        
    float NdV = saturate(dot(N, V));
    float HdV = saturate(dot(H, V));
    float NdH = saturate(dot(N, H));
    float HdL = saturate(dot(H, -L));   

    float envMapMipLevels = 12;

    //==============================================================         

    float3 albedo = tex.rgb * MatPropCB.BaseColorFactor;
    float3 F0 = lerp(0.04f, albedo, metalness);

    float D = D_GGX(NdH, roughness);    
    float3 F = F_Schlick(HdV, F0);
    float G = G_Smith(NdL, NdV, roughness);

    float kS = max(0, F);
    float kD = (1 - kS);

    float3 envReflections = g_envMap.SampleLevel(g_sampler, R, roughness * envMapMipLevels).rgb;
    envReflections *= kS * (1 - roughness) * metalness;

    float3 irradiance = g_irradiance.SampleLevel(g_sampler, N, 0).rgb;   

    float3 specularDFG = (D * F * G) / max(0.001f, 4.0f * NdV);
    float3 specular = specularDFG * DirLightCB.LightColor * kS;    
    
    float3 diffuse = irradiance * kD * albedo * DirLightCB.LightColor * NdL;  
    diffuse *= 1 - metalness;
    float3 ambient = irradiance * kD * albedo;   

    float3 Lo = diffuse + specular + ambient + envReflections;

    Lo = pow(Lo, 1.0f / 2.2f);
    return float4(Lo, tex.a);
}

float D_GGX(float NdH, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float denominator = (NdH * NdH * (a2 - 1.0f) + 1.0f);
    return a2 / max(0.001f, PI * denominator * denominator);
}

// 5 is the sharpness, can be modified
float3 F_Schlick(float cosTheta, float3 F0)
{
    return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);
}

float G_Smith(float NdL, float NdV, float roughness)
{
    float r = roughness + 1;
    float k = (r * r) / 8.0f;
    
    float ggxL = NdL / (NdL * (1.0f - k) + k);
    float ggxV = NdV / (NdV * (1.0f - k) + k);

    return ggxL * ggxV;
}

float G_Smith_IBL(float NdL, float NdV, float roughness)
{
    float r = roughness;
    float k = (r * r) / 2.0f;
    
    float ggxL = NdL / (NdL * (1.0f - k) + k);
    float ggxV = NdV / (NdV * (1.0f - k) + k);

    return ggxL * ggxV;
}