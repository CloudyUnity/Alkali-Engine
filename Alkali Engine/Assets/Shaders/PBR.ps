#define BUMP_2_CHANNEL 1

#define PI 3.141592654f

struct V_OUT
{
    float4 Position : SV_Position;
    float2 UV : TEXCOORD0;
    float3 Normal : NORMAL;    
    float3 Tangent : TANGENT;
    float3 Binormal : BINORMAL;
    float3 ViewDirection : TEXCOORD1;
};

struct DirectionalLight
{
    float3 AmbientColor;
    float p1;

    float3 LightDirection;
    float p2;

    float3 LightDiffuse;
    float SpecularPower;
};
ConstantBuffer<DirectionalLight> DirLightCB : register(b3);

struct MaterialProperties
{
    float3 BaseColorFactor;
    float Roughness;    

    float AlphaCutoff;
    float IOR;
    float Dispersion;
    float Metallic; // Unused until fixed
};
ConstantBuffer<MaterialProperties> MatPropCB : register(b1);

Texture2D g_texture : register(t0);
Texture2D g_normalMap : register(t1);
Texture2D g_specularMap : register(t2);
SamplerState g_sampler : register(s0);

float DistributionGGX(float3 NdH, float roughnessSq)
{
    float a = roughnessSq * roughnessSq;
    float denominator = (NdH * NdH * (a - 1.0f) + 1.0f);
    return a / (PI * denominator * denominator);
}

// HdV == cosTheta
// 5 is the sharpness, can be modified
float3 FresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0f - F0) * pow(1.0f - cosTheta, 5.0f);
}

float GeometrySmith(float NdL, float NdV, float roughnessSq)
{
    float ggxV = NdV / (NdV * (1.0f - roughnessSq) + roughnessSq);
    float ggxL = NdL / (NdL * (1.0f - roughnessSq) + roughnessSq);
    return ggxV * ggxL;
}

float4 main(V_OUT input) : SV_Target
{
    float4 tex = g_texture.Sample(g_sampler, input.UV);    

    if (tex.a < MatPropCB.AlphaCutoff)
        discard;

    tex.rgb = pow(tex.rgb, 2.2f);
    tex.rgb *= MatPropCB.BaseColorFactor;

#if BUMP_2_CHANNEL
    float2 bump = g_normalMap.Sample(g_sampler, input.UV).rg;

    float3 normalTangentSpace;
    normalTangentSpace.xy = bump * 2.0f - 1.0f;
    normalTangentSpace.z = sqrt(1.0f - dot(normalTangentSpace.xy, normalTangentSpace.xy));
#else
    float3 normalTangentSpace = g_normalMap.Sample(g_sampler, input.UV).rgb;
    normalTangentSpace.xyz = normalTangentSpace.xyz * 2.0f - 1.0f;
#endif

    float3 N = normalize(normalTangentSpace.x * input.Tangent + normalTangentSpace.y * input.Binormal + normalTangentSpace.z * input.Normal);    

    float3 specData = g_specularMap.Sample(g_sampler, input.UV).rgb;
    float specularIntensity = 1;
    float glossiness = 1;
    float metalness = specData.b * MatPropCB.Metallic;
    float roughness = specData.g * MatPropCB.Roughness;

    //return float4(0, MatPropCB.Roughness, MatPropCB.Metallic, 1);
    //return float4(specData, 1);
    //return float4(metalness, roughness, 0, 1);

    //==============================================================        

    float3 L = normalize(DirLightCB.LightDirection);
    float3 V = normalize(input.ViewDirection);
    float3 H = normalize(-L + V);

    float NdL = saturate(dot(N, -L));        
    float NdV = saturate(dot(N, V));
    float HdV = saturate(dot(H, V));
    float NdH = saturate(dot(N, H));

    float3 diffuse = tex.rgb * (1 - metalness) * (DirLightCB.AmbientColor + DirLightCB.LightDiffuse * NdL);

    float3 F0 = lerp(0.04f, tex.rgb, metalness);

    float D = DistributionGGX(NdH, roughness);    
    float3 F = FresnelSchlick(HdV, F0);
    float G = GeometrySmith(NdL, NdV, roughness);

    float specDenom = max(0.001f, 4.0f * max(0.001f, NdV) * max(0.001f, NdL));
    float3 specularDFG = NdL * D * F * G / specDenom;

    float4 finalCol;
    finalCol.rgb = diffuse + specularDFG;
    finalCol.rgb = pow(finalCol.rgb, 1.0f / 2.2f);
    finalCol.a = tex.a;

    //return float4(F, 1);

    return finalCol;
}